
###Production Dependencies
| **Dependency** | **Use** |
|----------|-------|
|babel-polyfill | Polyfill for Babel features that cannot be transpiled |
|bootstrap|CSS Framework|
|jquery|Only used to support toastr|
|react|React library |
|react-dom|React library for DOM rendering |
|react-redux|Redux library for connecting React components to Redux |
|react-router|React library for routing |
|react-router-redux|Keep React Router in sync with Redux application state|
|redux|Library for unidirectional data flows |
|redux-thunk|Async redux library|
|toastr|Display messages to the user|

###Development Dependencies
| **Dependency** | **Use** |
|----------|-------|
|babel-cli|Babel Command line interface |
|babel-core|Babel Core for transpiling the new JavaScript to old |
|babel-loader|Adds Babel support to Webpack |
|babel-plugin-react-display-name| Add displayName to React.createClass calls |
|babel-preset-es2015|Babel preset for ES2015|
|babel-preset-react| Add JSX support to Babel |
|babel-preset-react-hmre|Hot reloading preset for Babel|
|babel-register|Register Babel to transpile our Mocha tests|
|cheerio|Supports querying DOM with jQuery like syntax - Useful in testing and build process for HTML manipulation|
|colors|Adds color support to terminal |
|compression|Add gzip support to Express|
|cross-env|Cross-environment friendly way to handle environment variables|
|css-loader|Add CSS support to Webpack|
|enzyme|Simplified JavaScript Testing utilities for React|
|eslint|Lints JavaScript |
|eslint-plugin-import|Advanced linting of ES6 imports|
|eslint-plugin-react|Adds additional React-related rules to ESLint|
|eslint-watch|Add watch functionality to ESLint |
|eventsource-polyfill|Polyfill to support hot reloading in IE|
|expect|Assertion library for use with Mocha|
|express|Serves development and production builds|
|extract-text-webpack-plugin| Extracts CSS into separate file for production build | 
|file-loader| Adds file loading support to Webpack |
|jsdom|In-memory DOM for testing|
|mocha| JavaScript testing library |
|nock| Mock HTTP requests for testing |
|npm-run-all| Display results of multiple commands on single command line |
|open|Open app in default browser|
|react-addons-test-utils| Adds React TestUtils |
|redux-immutable-state-invariant|Warn when Redux state is mutated|
|redux-mock-store|Mock Redux store for testing|
|rimraf|Delete files |
|style-loader| Add Style support to Webpack |
|url-loader| Add url loading support to Webpack |
|webpack| Bundler with plugin system and integrated development server |
|webpack-dev-middleware| Adds middleware support to webpack |
|webpack-hot-middleware| Adds hot reloading to webpack |



React Component Approaches


ES6 Class component 

no autobind
Default props declared separately
Set initital state in constructor 

ES6 Stateless functional components

No class needed
Avoid 'this' keyword 
Enforced best practices 
High signal-to-noise ratio 
Enhanced code completion / intellisense 
Bloated components are obvious 
Easy to understand
Easy to test
Performance 


Use staless functional when possibly 
only use Class Component when in need of 

State 
Refs 
Lifecycle methods 
Child functions (for performance)

-------- 

Container components (Smart, Stateful, Controller view)
Little to no markup (back-end to the frontend)
Pass data and actions down
Knows about Redux
Often stateful
Connects to Redux Store and pase data down to child components

Presentation components (Dumb, Stateless, View)
Nearly all markup 
Receive data and actions via props 
Doesnt know about Redux 
Typically functional components



Redux 

Complex data flows 
Inter-component communication 
Non-heirarchial data 
Many actions 
Same data used in multiple places 

Redux 3 principles

One immutable store (state cant be changed)
Actions trigger changes 
Reducers (pure functions) update state


Data down, Actions up.
Unidirectional Flow (One way) .
Single Store with hierarchical reducers.
State is immutable 



Actions 
Action Creators 

Store
let store = createStore(reducer);
store.dispatch(action) 
store.subscribe(listener) 
store.getState() 
replaceReducer(nextReducer) 


Why Immutability ?

Clarity (who changed that state ? reducers ofc)
Performance (no expensive operation to check if state is changed, just compare)
Amazing debugging (time travel debbugging, go back in history, hot-reload)

Immutability 
To change state, return a new object

Copy old and create ne object (ES6) // Object.assign({}, state, {role: 'admin'});

Handling Immutable state (ES6)
Object.assign 
Spread operator 


Reducers 
Return new state based on action passed  (state,action=>state)
All Reducers are called on Each Dispatch 

---

Connecting React to Redux 

Container components
Focus on how things work 
Aware of Redux 
Subscribe to Redux state 
Dispatch Redux actions 
Generated by react-redux 

Presentation components
Focus on how things look 
Unaware of Redux 
Read data from props 
Invoke callbacks on props 
written by hand 


React-Redux library

Provider (Attaches app to store)

  <Provider store={this.props.store}>
    <App/>
  </Provider>


Connect (Creates container components) 

  Wraps our component so it's connected to the Redux store.

  Arguments passed to Connect
  mapStateToProps, // state that is exposed to component 
  What state should I expose as props 

  (Reselect, library for cashing if doing expensive operations in maping as filtering big lists)


  mapDispatchToProps // actions exposed
  What actions do I want on props 



Benefits:
No manual unsubscribe.
No lifecycle methods required (componentWillMount,componentWillUnmount,onChange)
Declare what subset of state you want 
Enhanced performance for free 



Async Calls in Redux 

Redux Async Libraries

redux-saga (Uses ES6 generators and rich domain-specific language )

Generators
Easy to test 
Hard to learn 

redux-thunk (Returns functions from action creators)

Functions
Clunky to test
Easy to learn 


Mock API 

